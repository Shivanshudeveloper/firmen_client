{"version":3,"file":"static/js/47.a9a05360.chunk.js","mappings":"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","sources":["../node_modules/framer-motion/dist/es/easing/ease.mjs","../node_modules/framer-motion/dist/es/easing/cubic-bezier.mjs","../node_modules/framer-motion/dist/es/easing/back.mjs","../node_modules/framer-motion/dist/es/animation/utils/easing.mjs","../node_modules/framer-motion/dist/es/easing/anticipate.mjs","../node_modules/framer-motion/dist/es/animation/legacy-popmotion/keyframes.mjs","../node_modules/framer-motion/dist/es/utils/offsets/time.mjs","../node_modules/framer-motion/dist/es/animation/legacy-popmotion/find-spring.mjs","../node_modules/framer-motion/dist/es/animation/legacy-popmotion/spring.mjs","../node_modules/framer-motion/dist/es/animation/legacy-popmotion/index.mjs","../node_modules/framer-motion/dist/es/animation/legacy-popmotion/decay.mjs","../node_modules/framer-motion/dist/es/easing/circ.mjs","../node_modules/framer-motion/dist/es/easing/modifiers/mirror.mjs","../node_modules/framer-motion/dist/es/easing/modifiers/reverse.mjs"],"sourcesContent":["import { mirrorEasing } from './modifiers/mirror.mjs';\nimport { reverseEasing } from './modifiers/reverse.mjs';\n\nconst easeIn = (p) => p * p;\nconst easeOut = reverseEasing(easeIn);\nconst easeInOut = mirrorEasing(easeIn);\n\nexport { easeIn, easeInOut, easeOut };\n","import { noop } from '../utils/noop.mjs';\n\n/*\n  Bezier function generator\n  This has been modified from GaÃ«tan Renaudeau's BezierEasing\n  https://github.com/gre/bezier-easing/blob/master/src/index.js\n  https://github.com/gre/bezier-easing/blob/master/LICENSE\n  \n  I've removed the newtonRaphsonIterate algo because in benchmarking it\n  wasn't noticiably faster than binarySubdivision, indeed removing it\n  usually improved times, depending on the curve.\n  I also removed the lookup table, as for the added bundle size and loop we're\n  only cutting ~4 or so subdivision iterations. I bumped the max iterations up\n  to 12 to compensate and this still tended to be faster for no perceivable\n  loss in accuracy.\n  Usage\n    const easeOut = cubicBezier(.17,.67,.83,.67);\n    const x = easeOut(0.5); // returns 0.627...\n*/\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nconst calcBezier = (t, a1, a2) => (((1.0 - 3.0 * a2 + 3.0 * a1) * t + (3.0 * a2 - 6.0 * a1)) * t + 3.0 * a1) *\n    t;\nconst subdivisionPrecision = 0.0000001;\nconst subdivisionMaxIterations = 12;\nfunction binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {\n    let currentX;\n    let currentT;\n    let i = 0;\n    do {\n        currentT = lowerBound + (upperBound - lowerBound) / 2.0;\n        currentX = calcBezier(currentT, mX1, mX2) - x;\n        if (currentX > 0.0) {\n            upperBound = currentT;\n        }\n        else {\n            lowerBound = currentT;\n        }\n    } while (Math.abs(currentX) > subdivisionPrecision &&\n        ++i < subdivisionMaxIterations);\n    return currentT;\n}\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n    // If this is a linear gradient, return linear easing\n    if (mX1 === mY1 && mX2 === mY2)\n        return noop;\n    const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);\n    // If animation is at start/end, return t without easing\n    return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\n}\n\nexport { cubicBezier };\n","import { cubicBezier } from './cubic-bezier.mjs';\nimport { mirrorEasing } from './modifiers/mirror.mjs';\nimport { reverseEasing } from './modifiers/reverse.mjs';\n\nconst backOut = cubicBezier(0.33, 1.53, 0.69, 0.99);\nconst backIn = reverseEasing(backOut);\nconst backInOut = mirrorEasing(backIn);\n\nexport { backIn, backInOut, backOut };\n","import { invariant } from '../../utils/errors.mjs';\nimport { cubicBezier } from '../../easing/cubic-bezier.mjs';\nimport { noop } from '../../utils/noop.mjs';\nimport { easeIn, easeInOut, easeOut } from '../../easing/ease.mjs';\nimport { circIn, circInOut, circOut } from '../../easing/circ.mjs';\nimport { backIn, backInOut, backOut } from '../../easing/back.mjs';\nimport { anticipate } from '../../easing/anticipate.mjs';\n\nconst easingLookup = {\n    linear: noop,\n    easeIn,\n    easeInOut,\n    easeOut,\n    circIn,\n    circInOut,\n    circOut,\n    backIn,\n    backInOut,\n    backOut,\n    anticipate,\n};\nconst easingDefinitionToFunction = (definition) => {\n    if (Array.isArray(definition)) {\n        // If cubic bezier definition, create bezier curve\n        invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`);\n        const [x1, y1, x2, y2] = definition;\n        return cubicBezier(x1, y1, x2, y2);\n    }\n    else if (typeof definition === \"string\") {\n        // Else lookup from table\n        invariant(easingLookup[definition] !== undefined, `Invalid easing type '${definition}'`);\n        return easingLookup[definition];\n    }\n    return definition;\n};\nconst isEasingArray = (ease) => {\n    return Array.isArray(ease) && typeof ease[0] !== \"number\";\n};\n\nexport { easingDefinitionToFunction, isEasingArray };\n","import { backIn } from './back.mjs';\n\nconst anticipate = (p) => (p *= 2) < 1 ? 0.5 * backIn(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));\n\nexport { anticipate };\n","import { easeInOut } from '../../easing/ease.mjs';\nimport { interpolate } from '../../utils/interpolate.mjs';\nimport { defaultOffset } from '../../utils/offsets/default.mjs';\nimport { convertOffsetToTimes } from '../../utils/offsets/time.mjs';\nimport { isEasingArray, easingDefinitionToFunction } from '../utils/easing.mjs';\n\nfunction defaultEasing(values, easing) {\n    return values.map(() => easing || easeInOut).splice(0, values.length - 1);\n}\nfunction keyframes({ keyframes: keyframeValues, ease = easeInOut, times, duration = 300, }) {\n    keyframeValues = [...keyframeValues];\n    /**\n     * Easing functions can be externally defined as strings. Here we convert them\n     * into actual functions.\n     */\n    const easingFunctions = isEasingArray(ease)\n        ? ease.map(easingDefinitionToFunction)\n        : easingDefinitionToFunction(ease);\n    /**\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n     * to reduce GC during animation.\n     */\n    const state = {\n        done: false,\n        value: keyframeValues[0],\n    };\n    /**\n     * Create a times array based on the provided 0-1 offsets\n     */\n    const absoluteTimes = convertOffsetToTimes(\n    // Only use the provided offsets if they're the correct length\n    // TODO Maybe we should warn here if there's a length mismatch\n    times && times.length === keyframeValues.length\n        ? times\n        : defaultOffset(keyframeValues), duration);\n    function createInterpolator() {\n        return interpolate(absoluteTimes, keyframeValues, {\n            ease: Array.isArray(easingFunctions)\n                ? easingFunctions\n                : defaultEasing(keyframeValues, easingFunctions),\n        });\n    }\n    let interpolator = createInterpolator();\n    return {\n        next: (t) => {\n            state.value = interpolator(t);\n            state.done = t >= duration;\n            return state;\n        },\n        flipTarget: () => {\n            keyframeValues.reverse();\n            interpolator = createInterpolator();\n        },\n    };\n}\n\nexport { defaultEasing, keyframes };\n","function convertOffsetToTimes(offset, duration) {\n    return offset.map((o) => o * duration);\n}\n\nexport { convertOffsetToTimes };\n","import { warning } from '../../utils/errors.mjs';\nimport { clamp } from '../../utils/clamp.mjs';\n\nconst safeMin = 0.001;\nconst minDuration = 0.01;\nconst maxDuration = 10.0;\nconst minDamping = 0.05;\nconst maxDamping = 1;\nfunction findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1, }) {\n    let envelope;\n    let derivative;\n    warning(duration <= maxDuration * 1000, \"Spring duration must be 10 seconds or less\");\n    let dampingRatio = 1 - bounce;\n    /**\n     * Restrict dampingRatio and duration to within acceptable ranges.\n     */\n    dampingRatio = clamp(minDamping, maxDamping, dampingRatio);\n    duration = clamp(minDuration, maxDuration, duration / 1000);\n    if (dampingRatio < 1) {\n        /**\n         * Underdamped spring\n         */\n        envelope = (undampedFreq) => {\n            const exponentialDecay = undampedFreq * dampingRatio;\n            const delta = exponentialDecay * duration;\n            const a = exponentialDecay - velocity;\n            const b = calcAngularFreq(undampedFreq, dampingRatio);\n            const c = Math.exp(-delta);\n            return safeMin - (a / b) * c;\n        };\n        derivative = (undampedFreq) => {\n            const exponentialDecay = undampedFreq * dampingRatio;\n            const delta = exponentialDecay * duration;\n            const d = delta * velocity + velocity;\n            const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq, 2) * duration;\n            const f = Math.exp(-delta);\n            const g = calcAngularFreq(Math.pow(undampedFreq, 2), dampingRatio);\n            const factor = -envelope(undampedFreq) + safeMin > 0 ? -1 : 1;\n            return (factor * ((d - e) * f)) / g;\n        };\n    }\n    else {\n        /**\n         * Critically-damped spring\n         */\n        envelope = (undampedFreq) => {\n            const a = Math.exp(-undampedFreq * duration);\n            const b = (undampedFreq - velocity) * duration + 1;\n            return -safeMin + a * b;\n        };\n        derivative = (undampedFreq) => {\n            const a = Math.exp(-undampedFreq * duration);\n            const b = (velocity - undampedFreq) * (duration * duration);\n            return a * b;\n        };\n    }\n    const initialGuess = 5 / duration;\n    const undampedFreq = approximateRoot(envelope, derivative, initialGuess);\n    duration = duration * 1000;\n    if (isNaN(undampedFreq)) {\n        return {\n            stiffness: 100,\n            damping: 10,\n            duration,\n        };\n    }\n    else {\n        const stiffness = Math.pow(undampedFreq, 2) * mass;\n        return {\n            stiffness,\n            damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),\n            duration,\n        };\n    }\n}\nconst rootIterations = 12;\nfunction approximateRoot(envelope, derivative, initialGuess) {\n    let result = initialGuess;\n    for (let i = 1; i < rootIterations; i++) {\n        result = result - envelope(result) / derivative(result);\n    }\n    return result;\n}\nfunction calcAngularFreq(undampedFreq, dampingRatio) {\n    return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);\n}\n\nexport { calcAngularFreq, findSpring, maxDamping, maxDuration, minDamping, minDuration };\n","import { findSpring, calcAngularFreq } from './find-spring.mjs';\nimport { velocityPerSecond } from '../../utils/velocity-per-second.mjs';\n\nconst durationKeys = [\"duration\", \"bounce\"];\nconst physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\nfunction isSpringType(options, keys) {\n    return keys.some((key) => options[key] !== undefined);\n}\nfunction getSpringOptions(options) {\n    let springOptions = {\n        velocity: 0.0,\n        stiffness: 100,\n        damping: 10,\n        mass: 1.0,\n        isResolvedFromDuration: false,\n        ...options,\n    };\n    // stiffness/damping/mass overrides duration/bounce\n    if (!isSpringType(options, physicsKeys) &&\n        isSpringType(options, durationKeys)) {\n        const derived = findSpring(options);\n        springOptions = {\n            ...springOptions,\n            ...derived,\n            velocity: 0.0,\n            mass: 1.0,\n        };\n        springOptions.isResolvedFromDuration = true;\n    }\n    return springOptions;\n}\nconst velocitySampleDuration = 5;\n/**\n * This is based on the spring implementation of Wobble https://github.com/skevy/wobble\n */\nfunction spring({ keyframes, restDelta, restSpeed, ...options }) {\n    let origin = keyframes[0];\n    let target = keyframes[keyframes.length - 1];\n    /**\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n     * to reduce GC during animation.\n     */\n    const state = { done: false, value: origin };\n    const { stiffness, damping, mass, velocity, duration, isResolvedFromDuration, } = getSpringOptions(options);\n    let resolveSpring = zero;\n    let initialVelocity = velocity ? -(velocity / 1000) : 0.0;\n    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n    function createSpring() {\n        const initialDelta = target - origin;\n        const undampedAngularFreq = Math.sqrt(stiffness / mass) / 1000;\n        /**\n         * If we're working on a granular scale, use smaller defaults for determining\n         * when the spring is finished.\n         *\n         * These defaults have been selected emprically based on what strikes a good\n         * ratio between feeling good and finishing as soon as changes are imperceptible.\n         */\n        const isGranularScale = Math.abs(initialDelta) < 5;\n        restSpeed || (restSpeed = isGranularScale ? 0.01 : 2);\n        restDelta || (restDelta = isGranularScale ? 0.005 : 0.5);\n        if (dampingRatio < 1) {\n            const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\n            // Underdamped spring\n            resolveSpring = (t) => {\n                const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n                return (target -\n                    envelope *\n                        (((initialVelocity +\n                            dampingRatio * undampedAngularFreq * initialDelta) /\n                            angularFreq) *\n                            Math.sin(angularFreq * t) +\n                            initialDelta * Math.cos(angularFreq * t)));\n            };\n        }\n        else if (dampingRatio === 1) {\n            // Critically damped spring\n            resolveSpring = (t) => target -\n                Math.exp(-undampedAngularFreq * t) *\n                    (initialDelta +\n                        (initialVelocity + undampedAngularFreq * initialDelta) *\n                            t);\n        }\n        else {\n            // Overdamped spring\n            const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n            resolveSpring = (t) => {\n                const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n                // When performing sinh or cosh values can hit Infinity so we cap them here\n                const freqForT = Math.min(dampedAngularFreq * t, 300);\n                return (target -\n                    (envelope *\n                        ((initialVelocity +\n                            dampingRatio * undampedAngularFreq * initialDelta) *\n                            Math.sinh(freqForT) +\n                            dampedAngularFreq *\n                                initialDelta *\n                                Math.cosh(freqForT))) /\n                        dampedAngularFreq);\n            };\n        }\n    }\n    createSpring();\n    return {\n        next: (t) => {\n            const current = resolveSpring(t);\n            if (!isResolvedFromDuration) {\n                let currentVelocity = initialVelocity;\n                if (t !== 0) {\n                    /**\n                     * We only need to calculate velocity for under-damped springs\n                     * as over- and critically-damped springs can't overshoot, so\n                     * checking only for displacement is enough.\n                     */\n                    if (dampingRatio < 1) {\n                        const prevT = Math.max(0, t - velocitySampleDuration);\n                        currentVelocity = velocityPerSecond(current - resolveSpring(prevT), t - prevT);\n                    }\n                    else {\n                        currentVelocity = 0;\n                    }\n                }\n                const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n                const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;\n                state.done =\n                    isBelowVelocityThreshold && isBelowDisplacementThreshold;\n            }\n            else {\n                state.done = t >= duration;\n            }\n            state.value = state.done ? target : current;\n            return state;\n        },\n        flipTarget: () => {\n            initialVelocity = -initialVelocity;\n            [origin, target] = [target, origin];\n            createSpring();\n        },\n    };\n}\nspring.needsInterpolation = (a, b) => typeof a === \"string\" || typeof b === \"string\";\nconst zero = (_t) => 0;\n\nexport { spring };\n","import { keyframes } from './keyframes.mjs';\nimport { spring } from './spring.mjs';\nimport { decay } from './decay.mjs';\nimport { sync, cancelSync } from '../../frameloop/index.mjs';\nimport { interpolate } from '../../utils/interpolate.mjs';\n\nconst types = {\n    decay,\n    keyframes: keyframes,\n    tween: keyframes,\n    spring,\n};\nfunction loopElapsed(elapsed, duration, delay = 0) {\n    return elapsed - duration - delay;\n}\nfunction reverseElapsed(elapsed, duration = 0, delay = 0, isForwardPlayback = true) {\n    return isForwardPlayback\n        ? loopElapsed(duration + -elapsed, duration, delay)\n        : duration - (elapsed - duration) + delay;\n}\nfunction hasRepeatDelayElapsed(elapsed, duration, delay, isForwardPlayback) {\n    return isForwardPlayback ? elapsed >= duration + delay : elapsed <= -delay;\n}\nconst framesync = (update) => {\n    const passTimestamp = ({ delta }) => update(delta);\n    return {\n        start: () => sync.update(passTimestamp, true),\n        stop: () => cancelSync.update(passTimestamp),\n    };\n};\nfunction animateValue({ duration, driver = framesync, elapsed = 0, repeat: repeatMax = 0, repeatType = \"loop\", repeatDelay = 0, keyframes: keyframes$1, autoplay = true, onPlay, onStop, onComplete, onRepeat, onUpdate, type = \"keyframes\", ...options }) {\n    const initialElapsed = elapsed;\n    let driverControls;\n    let repeatCount = 0;\n    let computedDuration = duration;\n    let isComplete = false;\n    let isForwardPlayback = true;\n    let interpolateFromNumber;\n    const animator = types[keyframes$1.length > 2 ? \"keyframes\" : type] || keyframes;\n    const origin = keyframes$1[0];\n    const target = keyframes$1[keyframes$1.length - 1];\n    let state = { done: false, value: origin };\n    /**\n     * If this value needs interpolation (ie is non-numerical), set up an interpolator.\n     * TODO: Keyframes animation also performs this step. This could be removed so it only happens here.\n     */\n    const { needsInterpolation } = animator;\n    if (needsInterpolation && needsInterpolation(origin, target)) {\n        interpolateFromNumber = interpolate([0, 100], [origin, target], {\n            clamp: false,\n        });\n        keyframes$1 = [0, 100];\n    }\n    const animation = animator({\n        ...options,\n        duration,\n        keyframes: keyframes$1,\n    });\n    function repeat() {\n        repeatCount++;\n        if (repeatType === \"reverse\") {\n            isForwardPlayback = repeatCount % 2 === 0;\n            elapsed = reverseElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback);\n        }\n        else {\n            elapsed = loopElapsed(elapsed, computedDuration, repeatDelay);\n            if (repeatType === \"mirror\")\n                animation.flipTarget();\n        }\n        isComplete = false;\n        onRepeat && onRepeat();\n    }\n    function complete() {\n        driverControls && driverControls.stop();\n        onComplete && onComplete();\n    }\n    function update(delta) {\n        if (!isForwardPlayback)\n            delta = -delta;\n        elapsed += delta;\n        if (!isComplete) {\n            state = animation.next(Math.max(0, elapsed));\n            if (interpolateFromNumber)\n                state.value = interpolateFromNumber(state.value);\n            isComplete = isForwardPlayback ? state.done : elapsed <= 0;\n        }\n        onUpdate && onUpdate(state.value);\n        if (isComplete) {\n            if (repeatCount === 0) {\n                computedDuration =\n                    computedDuration !== undefined ? computedDuration : elapsed;\n            }\n            if (repeatCount < repeatMax) {\n                hasRepeatDelayElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback) && repeat();\n            }\n            else {\n                complete();\n            }\n        }\n    }\n    function play() {\n        onPlay && onPlay();\n        driverControls = driver(update);\n        driverControls.start();\n    }\n    autoplay && play();\n    return {\n        stop: () => {\n            onStop && onStop();\n            driverControls && driverControls.stop();\n        },\n        /**\n         * Set the current time of the animation. This is purposefully\n         * mirroring the WAAPI animation API to make them interchanagable.\n         * Going forward this file should be ported more towards\n         * https://github.com/motiondivision/motionone/blob/main/packages/animation/src/Animation.ts\n         * Which behaviourally adheres to WAAPI as far as possible.\n         *\n         * WARNING: This is not safe to use for most animations. We currently\n         * only use it for handoff from WAAPI within Framer.\n         *\n         * This animation function consumes time every frame rather than being sampled for time.\n         * So the sample() method performs some headless frames to ensure\n         * repeats are handled correctly. Ideally in the future we will replace\n         * that method with this, once repeat calculations are pure.\n         */\n        set currentTime(t) {\n            elapsed = initialElapsed;\n            update(t);\n        },\n        /**\n         * animate() can't yet be sampled for time, instead it\n         * consumes time. So to sample it we have to run a low\n         * temporal-resolution version.\n         */\n        sample: (t) => {\n            elapsed = initialElapsed;\n            const sampleResolution = duration && typeof duration === \"number\"\n                ? Math.max(duration * 0.5, 50)\n                : 50;\n            let sampleElapsed = 0;\n            update(0);\n            while (sampleElapsed <= t) {\n                const remaining = t - sampleElapsed;\n                update(Math.min(remaining, sampleResolution));\n                sampleElapsed += sampleResolution;\n            }\n            return state;\n        },\n    };\n}\n\nexport { animateValue, hasRepeatDelayElapsed, loopElapsed, reverseElapsed };\n","function decay({ \n/**\n * The decay animation dynamically calculates an end of the animation\n * based on the initial keyframe, so we only need to define a single keyframe\n * as default.\n */\nkeyframes = [0], velocity = 0, power = 0.8, timeConstant = 350, restDelta = 0.5, modifyTarget, }) {\n    const origin = keyframes[0];\n    /**\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n     * to reduce GC during animation.\n     */\n    const state = { done: false, value: origin };\n    let amplitude = power * velocity;\n    const ideal = origin + amplitude;\n    const target = modifyTarget === undefined ? ideal : modifyTarget(ideal);\n    /**\n     * If the target has changed we need to re-calculate the amplitude, otherwise\n     * the animation will start from the wrong position.\n     */\n    if (target !== ideal)\n        amplitude = target - origin;\n    return {\n        next: (t) => {\n            const delta = -amplitude * Math.exp(-t / timeConstant);\n            state.done = !(delta > restDelta || delta < -restDelta);\n            state.value = state.done ? target : target + delta;\n            return state;\n        },\n        flipTarget: () => { },\n    };\n}\n\nexport { decay };\n","import { mirrorEasing } from './modifiers/mirror.mjs';\nimport { reverseEasing } from './modifiers/reverse.mjs';\n\nconst circIn = (p) => 1 - Math.sin(Math.acos(p));\nconst circOut = reverseEasing(circIn);\nconst circInOut = mirrorEasing(circOut);\n\nexport { circIn, circInOut, circOut };\n","// Accepts an easing function and returns a new one that outputs mirrored values for\n// the second half of the animation. Turns easeIn into easeInOut.\nconst mirrorEasing = (easing) => (p) => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;\n\nexport { mirrorEasing };\n","// Accepts an easing function and returns a new one that outputs reversed values.\n// Turns easeIn into easeOut.\nconst reverseEasing = (easing) => (p) => 1 - easing(1 - p);\n\nexport { reverseEasing };\n"],"names":["easeIn","p","easeOut","reverseEasing","easeInOut","mirrorEasing","calcBezier","t","a1","a2","subdivisionPrecision","subdivisionMaxIterations","cubicBezier","mX1","mY1","mX2","mY2","noop","getTForX","aX","x","lowerBound","upperBound","currentX","currentT","i","Math","abs","binarySubdivide","backOut","backIn","backInOut","easingLookup","linear","circIn","circInOut","circOut","anticipate","pow","easingDefinitionToFunction","definition","Array","isArray","invariant","length","_definition","_slicedToArray","undefined","concat","isEasingArray","ease","keyframes","_ref","keyframeValues","_ref$ease","times","_ref$duration","duration","_toConsumableArray","easingFunctions","map","state","done","value","absoluteTimes","offset","o","convertOffsetToTimes","defaultOffset","createInterpolator","interpolate","values","easing","splice","interpolator","next","flipTarget","reverse","safeMin","minDuration","maxDuration","minDamping","maxDamping","findSpring","envelope","derivative","_ref$bounce","bounce","_ref$velocity","velocity","_ref$mass","mass","warning","dampingRatio","clamp","undampedFreq","exponentialDecay","delta","a","b","calcAngularFreq","c","exp","d","e","f","g","initialGuess","result","rootIterations","approximateRoot","isNaN","stiffness","damping","sqrt","durationKeys","physicsKeys","isSpringType","options","keys","some","key","spring","restDelta","restSpeed","_objectWithoutProperties","_excluded","origin","target","_getSpringOptions","springOptions","_objectSpread","isResolvedFromDuration","derived","getSpringOptions","resolveSpring","zero","initialVelocity","createSpring","initialDelta","undampedAngularFreq","isGranularScale","angularFreq","sin","cos","dampedAngularFreq","freqForT","min","sinh","cosh","current","currentVelocity","prevT","max","velocityPerSecond","isBelowVelocityThreshold","isBelowDisplacementThreshold","_ref2","needsInterpolation","_t","types","decay","_ref$keyframes","_ref$power","power","_ref$timeConstant","timeConstant","_ref$restDelta","modifyTarget","amplitude","ideal","tween","loopElapsed","elapsed","arguments","framesync","update","passTimestamp","start","sync","stop","cancelSync","animateValue","driverControls","interpolateFromNumber","_ref2$driver","driver","_ref2$elapsed","_ref2$repeat","repeat","repeatMax","_ref2$repeatType","repeatType","_ref2$repeatDelay","repeatDelay","keyframes$1","_ref2$autoplay","autoplay","onPlay","onStop","onComplete","onRepeat","onUpdate","_ref2$type","type","initialElapsed","repeatCount","computedDuration","isComplete","isForwardPlayback","animator","animation","delay","reverseElapsed","hasRepeatDelayElapsed","currentTime","sample","sampleResolution","sampleElapsed","remaining","acos"],"sourceRoot":""}